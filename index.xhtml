<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>クロッシング問題 - 夏色日傘のCodeIQ解答</title>
    <link rel="stylesheet" href="index.css"/>
    <!-- 以下、MathML表示用スタイル及びスクリプト。［出典： http://mdgw.hateblo.jp/entry/20101220/1292873468］ -->
    <link rel="stylesheet" href="display-mathml.css" />
    <script src="display-mathml.js"></script>
  </head>
  <body>
    <h1>交差点をすばやく数えよう！ -クロッシング問題-</h1>
    <div class="lastModified">作成：2013-09-03 夏色日傘（<a href="https://twitter.com/shade0710math">@shade0710math</a>）</div>
    <h2>はじめに</h2>
    <p>このたび、9 月 2 日早朝まで <a href="https://codeiq.jp/">CodeIQ</a> にて出題されていた、<a href="https://codeiq.jp/ace/yuki_hiroshi/q432">結城浩先生のクロッシング問題</a>を解いてみました。ちょっとした線形代数の知識と、これまたちょっとしたアルゴリズムの知識さえあればあっさり解ける問題でした。</p>
    <p>なお、この問題は「正解を <em>3 秒以内に</em>出力せよ」というミッションになっています。素朴な実装でも正解を導き出せるのですが、いかにして実行時間を短くできるかということで挑戦者の皆さんの心に火をつけてしまったようで、気付けば結城先生の問題の中で過去一番の人気問題となっていたようです（<a href="#note01">注1</a>）。アルゴリズムを工夫するなど正攻法で時短を試みた人もいれば C などの高速な言語で実装した人もいて、様々なアプローチがあるのだなぁと思いました。</p>
    <p>ちなみに、私は Java で実装しており、最初は素朴な（計算量 <code>O(<var>n</var><sup>2</sup>)</code> の）アルゴリズムを用いて 50 秒近くかけて出力していました。しかし、効率の良い（計算量 <code>O(<var>n</var>log<var>n</var>)</code> の）アルゴリズムを利用することで、約 0.7 秒（元の 1/70 の時間!!）で出力することができました。そして、ファイル読み込み時の処理を改善（<a href="#note02">注2</a>）した結果、実行時間を約 <em>0.2 秒</em>にまで短縮することができました。</p>
    <h2>クロッシング問題とは</h2>
    <p>クロッシング問題とは、光学素子（クロッシング素子）の間を飛び交う光線の交差点の個数を求める問題です。</p>
    <p><var>n</var> 個のクロッシング素子には光線のスタート側とゴール側のそれぞれに番号が振られており、スタート側には 1 から <var>n</var> までの数が順番に、ゴール側には 1 から <var>n</var> までの数がランダムに振られています。そして、スタート側の素子からゴール側の同じ番号の素子に向かって光線が飛んでいくようになっています。</p>
    <p>クロッシング素子の並びがファイル crossing.txt に記載されていました（現在は公開終了となっています）。行番号がスタート側の素子の番号を、各行に書かれている整数がゴール側の素子の番号を表しています。この crossing.txt をもとに光線の交差点の数を求めるのが、今回解いたクロッシング問題なのです。</p>
    <h2>実装したプログラム</h2>
    <p>詳しい解説は「<a href="#description">解説</a>」の項を参照願います。</p>
    <h3>Crossing.java</h3>
    <p>クロッシング問題を解くためのクラスです。<code>getInstance</code> メソッドでインスタンスを取得し、<code>solve</code> メソッド（パラメータはファイル名）でクロッシング問題を解きます。</p>
    <div class="source">
      <pre><code>package codeiq.hyuki.crossing;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 * &lt;p&gt;クロッシング問題のソルバークラスです。&lt;/p&gt;
 * @author Higasa Natsuiro (shade0710math)
 */
public class Crossing
{
    private static final Crossing instance = new Crossing();
    private Crossing(){}
    
    /**
     * &lt;p&gt;このクラスの唯一（シングルトン）のインスタンスを返します。&lt;/p&gt;
     * 
     * @return このクラスの唯一のインスタンス
     */
    public static Crossing getInstance()
    {
        return instance;
    }
    
    /**
     * &lt;p&gt;与えられた名前のファイルを読み込み、そのデータの「交差点」の数を返します。
     * マージソートを用いることで高速なカウントを実現しています。&lt;/p&gt;
     * @param fileName ファイル名
     * @return 交差点の数
     */
    public long solve( String fileName )
    {
        // ファイルは files フォルダにあるものとする
        try( BufferedReader br = new BufferedReader( new FileReader( new File( "files", fileName ) ) ) ) {
            
            final int INITIAL_SIZE = 10;
            long[] numbers = new long[ INITIAL_SIZE ];
            int lineNumber = 0;
            
            // ファイルを一行ずつ読み込む
            for( String line = br.readLine(); line != null; line = br.readLine() ) {
                // 読み込んだ行数が多ければ、数字リストのサイズを増やす
                if( numbers.length &lt;= lineNumber ) {
                    numbers = Arrays.copyOf( numbers, numbers.length * 2 );
                }

                // 現在の数字を数字リストに登録。
                numbers[ lineNumber ] = Integer.parseInt( line );
                lineNumber++;
            }
            // 交点の数をカウント
            long[] array = Arrays.copyOf( numbers, lineNumber );
            long result = count( array, 0, array.length - 1 );
            
            return result;
        }
        catch ( IOException e ) {
            throw new RuntimeException( e );
        }
    }

    /**
     * &lt;p&gt;マージソートを利用して入力配列から転倒数をカウントします。&lt;/p&gt;
     * @param array 入力数列
     * @param L ソート範囲の左端（ソート範囲に含む）
     * @param R ソート範囲の右端（ソート範囲に含む）
     * @return 転倒数
     */
    private long count( long[] array, int L, int R )
    {
        long result = 0;
        
        // ソート対象の配列のサイズが 1 以下ならばソートの必要はなく、転倒数のカウントも実行しない
        if( L &lt; R ) {
            // 左右に分割して各々をソート
            int m = ( L + R + 1 ) / 2;
            result += ( count( array, L, m - 1 ) + count( array, m, R ) );
            
            // 左右の部分配列を作業領域にコピー
            long[] left = Arrays.copyOfRange( array, L, m );
            long[] right = Arrays.copyOfRange( array, m, R + 1 );
            
            int l = 0;  // 左部分列のポインタ
            int r = 0;  // 右部分列のポインタ
            int i = L;  // 元の配列のポインタ
            
            // どちらかの部分配列をスキャンし終わるまで部分配列をマージする
            while( l &lt; left.length &amp;&amp; r &lt; right.length ) {
                // 初項どうしを比べる
                // 左部分配列のほうが大きくなければ左部分配列から要素を取り出して元の配列に戻す
                if( left[ l ] &lt;= right[ r ] ) {
                    array[ i ] = left[ l ];
                    //ポインタを進めておく
                    l++;
                    i++;
                }
                // さもなければ右部分配列から要素を取り出して元の配列に戻す
                else {
                    array[ i ] = right[ r ];
                    // ポインタを進めておく
                    r++;
                    i++;
                    // 左部分配列の要素を飛び越えて書き戻すため、その要素数だけ転倒数をカウントする
                    result += ( left.length - l );
                }
            }
            System.arraycopy( left, l, array, i, left.length - l );
            i += ( left.length - l );
            System.arraycopy( right, r, array, i, right.length - r );
            i += ( right.length - r );
        }
        return result;
    }
}</code></pre>
    </div>
    <h3>MainCrossing.java</h3>
    <p>クロッシング問題を実行するクラスです。</p>
    <div class="source">
      <pre><code>package codeiq.hyuki.crossing.main;

import codeiq.hyuki.crossing.Crossing;

public class MainCrossing
{
    public static void main( String... args )
    {
        // クロッシング問題ソルバーの作成
        Crossing crossing = Crossing.getInstance();
        
        // クロッシング問題を解く
        long start = System.currentTimeMillis();  // 測定開始
        long count = crossing.solve( "crossing.txt" );
        long end = System.currentTimeMillis();    // 測定終了
        
        // ミリ秒単位でも計算時間を求めておく（これ自体は答案の評価に関係しない）
        long time = ( end - start ) / 1000L;
        
        // 答案の出力（標準出力ではなく answer.txt に直接書き出してもよかった？）
        System.out.printf( "%d,%d%n", count, time );
        System.out.println( "ENV: Java 7" );
        System.out.printf( "%nミリ秒単位の実行時間：%d [msec]%n", ( end - start ) );
    }
}</code></pre>
    </div>

    <h3>実行結果</h3>
    <p>実行結果は以下の通りです。Java だと約 220 [msec] が限界でしょうか……。</p>
    <div class="source">
      <pre><code>24689222839,0
ENV: Java 7

ミリ秒単位の実行時間：215 [msec]</code></pre>
    </div>
    
    <h2 id="description">解説</h2>
    <h3>交差点の数を求める、とは？</h3>
    <p>素子の個数を 3 とした場合の全 6 通りの配置や、サンプル（素子 9 個で [3, 1, 4, 5, 9, 2, 6, 8, 7] の配置）を眺めていると、交差点の数は<em>「隣接したペアで左右の大小が入れ替わっているものの数」として求められる</em>ということに気付きます。言い換えると、「数列 {<var>a</var><sub><var>n</var></sub>} をゴール側の素子の配列、自然数 <var>n</var> を素子の個数とし、2 つの任意の自然数 <var>i</var>, <var>j</var> に対して <var>i</var> &lt; <var>j</var> &#8804; <var>n</var> かつ <var>a</var><sub><var>i</var></sub> &gt; <var>a</var><sub><var>j</var></sub> を満たすペア (<var>i</var>, <var>j</var>) の個数」こそが、クロッシング問題において求めるべき交差点の数であるといえます。</p>
    <p>線形台数を学んだことのあるかたなら、これを聞くと「転倒数（<a href="#note04">注4</a>）」そのものであると気付くことでしょう。つまり、この問題は<em>本質的には、与えられたデータ（より正確にいうと、行番号から各行のデータへの置換）に対する転倒数を求める問題である</em>ということができるでしょう。</p>
    <p>原理的には、クロッシング素子 2 個の番号からなるペア（順序対）をすべて求め、要素の大小順序が入れ替わっているものを数え上げていけば求められます。実装上は、ファイル crossing.txt から一行読み込むたびに以前に読んだデータ（配列に保持しておきます）の中で今読み込んだ行のデータよりも大きいものがないかを探し、あったらその個数だけカウントアップすればよいでしょう。</p>
    <h3>交差点の数を「素早く」求めるには？</h3>
    <p>上記では、「ある行のデータを読み込んだとき、それより前に読み込んだすべてのデータとの大小を比較し、現在読み込んだデータより大きいものの個数をカウントする」という手法をとっています。このとき、<var>k</var> 行目を読み込んだ場合はその前の (<var>k</var> + 1) 個のデータと比較することになるため、crossing.txt に記載されているデータが <var>n</var> 個あるとすると、トータルの比較回数は以下のように <var>n</var> の 2 次式で表すことができます。</p>
    <div class="math">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <munderover>
          <mi mathvariant="normal">&#8721;</mi>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mi>n</mi>
        </munderover>
        <mrow>
          <mo>(</mo>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
          <mo>)</mo>
        </mrow>
        <mo>=</mo>
        <mfrac>
          <mrow>
          <mi>n</mi>
          <mo>&#x2062;</mo>
          <mo>(</mo>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
          <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </mfrac>
      </math>
    </div>
    <p>上記の式より、転倒数を求める<ruby>素朴<rp>(</rp><rt>ナイーブ</rt><rp>)</rp></ruby>なアルゴリズムの計算量は、<var>O</var> 記法を用いて <code>O(<var>n</var><sup>2</sup>)</code> と表されます。</p>
    <p>ところで、「ある行のデータを読み込んだとき、それより前に読み込んだすべてのデータとの大小を比較し、現在読み込んだデータより大きいものの個数をカウントする」という操作は、「ある行のデータを読み込んだとき、それより前に読み込んだすべてのデータとの大小を比較し、現在読み込んだデータより大きいものと入れ替え続けて適切な位置に挿入する」という操作に似ています。この操作は、有名なソーティングアルゴリズムのひとつである「<em>挿入ソート（insertion sort）</em>」そのものです。</p>
    <p>ソーティングアルゴリズムを学んだことがある人ならば、次のことを考えるでしょう。上記の素朴なアルゴリズムが挿入ソートと似ていて、どちらもデータ数に対する計算量が <code>O(<var>n</var><sup>2</sup>)</code> であるならば、計算量が <code>O(<var>n</var>log<var>n</var>)</code> であるようなソーティングアルゴリズムを利用することで、カウントにかかる計算量を減らせるのではないかと。</p>
    <p>私もそこに着目し、データをすべて読み込んだ後で「<a href="http://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88"><em>マージソート（merge sort）</em></a>」しながらカウントする方法を採用しました。具体的には、「ソートされた部分配列からデータを取り出して元の配列に書き出す際、データが右側の部分配列から取り出された場合は左部分配列に残っている要素数を転倒数に加算する」というロジックを入れました。<em>右部分配列の要素が先に取り出されるということは、その要素は左部分配列のすべての要素よりも小さい</em>ということなので、その要素と左部分配列の残りの全要素との大小関係が入れ替わっていることになります。素朴なアルゴリズムの場合は大小比較 1 回につき 1 カウントしかできませんが、<em>マージソートを利用したアルゴリズムの場合は大小比較 1 回につき複数個ぶんのカウントが可能となるため、カウントする回数を大幅に減らすことができます</em>（<a href="#note05">注5</a>）。</p>
    <h3>マージソート vs クイックソート</h3>
    <p>計算量が <code>O(<var>n</var>log<var>n</var>)</code> であるようなソーティングアルゴリズムはマージソート以外にもいくつか存在します。例えば、代表的なものに「<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88"><em>クイックソート（quick sort）</em></a>」があります。クイックソートはその名の通り非常に高速に配列をソートできるアルゴリズムで、比較ソートとしては最速だと言われています。</p>
    <p>それを聞くと、「へえ、マージソートよりもクイックソートのほうが速そうだな。ならば、クイックソートを使ったほうが速くカウントできるのでは？」と考える人もいらっしゃるかもしれません。しかし、<em>それは大きな落とし穴</em>。この問題の場合、クイックソートは絶対に使ってはいけないアルゴリズムなのです。</p>
    <h3>クイックソートは使うべからず！</h3>
    <p>転倒数のカウントにおいてクイックソートを使ってはならない理由はいくつかあります。</p>
    <p>まず、<em>クイックソートの計算量が <code>O(<var>n</var>log<var>n</var>)</code> とは限らない</em>ことです。要素が（一様に）ランダムに並んでいる配列をソートする場合は確かに最速を誇るのですが、最初から昇順または降順にソートされている配列をソートする場合には計算量は <code>O(<var>n</var>log<var>n</var>)</code> ではなく <code>O(<var>n</var><sup>2</sup>)</code> となり、かえって遅くなってしまいます。この点に関しては一応、ソートの際にピボット（枢軸ともいう）をランダムで選ぶ「乱択クイックソート」（参考：<a href="http://www.amazon.co.jp/dp/479736100X">『数学ガール／乱択アルゴリズム』</a>）を利用するなどの工夫を施せば解決することはできます。よって、この点に関してはあまり気にしなくてよいでしょう。</p>
    <p>本質的な問題点は別にあります。それは、<em>クイックソートは安定なアルゴリズムではない</em>ことです。クイックソートは「配列の要素の中からピボットとなる要素を一つ選び、大きさがピボット以下の要素を左部分配列に、ピボットより大きい要素を右部分配列に、それぞれ集めたのち、左右の部分配列に対してそれぞれ再帰的に同様の分割を施していく」というソート方法です。ところが、配列を左右に分割する過程で部分配列内での要素の並びがコロコロ替わるため、要素どうし（ピボットとそれ以外と）の比較の際に正確にカウントできないのです。実際、クイックソートで実装したときに、素朴なアルゴリズムで求めたときよりも少ない値を出力したため、数え漏れが発生していると気付いて没にせざるを得ませんでした。</p>
    <p>左右の部分配列に分割したあと、各部分配列内の要素の並びを分割前のインデックス順になるように並べ直すという前処理（後処理？）を施せば正確にカウントできそうな気がしますが、そのぶんのオーバーヘッドがどれほど大きくなるかが気になるところです。ただ、実際に試したわけではありませんが、そこまでしてクイックソートを使うよりも、マージソートを利用したほうが実装が簡単でかつ高速なカウントを実現できそうな気がします。</p>
    
    <h2>終わりに</h2>
    <p>今回は「交差点の数をどうやって数えるか」「いかにして効率よくカウントするか」に気付くのがポイントでしたが、意外とあっさり気付くことができてラッキーでした。そして、なかなか楽しい問題でした。</p>
    <p>もしもこれが、「3 つの交差点が重なって 1 つになる」とか、「同一番号の素子が複数個あって、1 個の素子から同一番号の素子すべてに光線が放たれる」などのような仕様だったら……と考えると恐ろしくなりますね(笑)。</p>
    <p>結城先生、いつも楽しい問題を出していただき、ありがとうございます。次回も楽しみにしております。今後ともよろしくお願い致します。</p>
    
    <hr class="separator" />
    <ul class="note">
      <li id="note01">注1. 他の問題は挑戦者数が 200 人に満たなかったのですが、この問題だけなんと 432 人に!!（退会済みのかたがいらっしゃったようで、実質430人だそうです）</li>
      <li id="note02">注2. java.util.Scanner クラスを使っていたところを java.io.BufferedReader クラスを用いるようにしたほか、「数字以外のものを読み込んだ場合は例外を投げる」という処理（分岐）を入れていたところを削除しました（<a href="#note03">注3</a>）。</li>
      <li id="note03">注3. Integer.parseInt メソッドを使っているため、数字以外のものが読み込まれると例外が投げられます。よって、例外を投げるための分岐をわざわざループ中に組み込むのは無駄だという判断です。なお、既に読み込まれたことがある数や負の数などの不正なデータは入力ファイルに記載されていないという前提で組んでいますが、本来はそのようなデータのチェックが必要になるかと思われます。</li>
      <li id="note04">注4. 結城先生のフィードバックでは「逆転数」という用語が用いられています。私は転倒数と教わったので、本文中では「転倒数」で統一しています。</li>
      <li id="note05">注5. 足し算 1 回の計算量（計算時間）がオペランド（足される数と足す数）の値に依存しないものとした場合の話です。現代のコンピュータで高級言語を用いて実装した場合は概ねこの仮定を満たすかと思いますが、もしもこの仮定を満たさないような環境であれば、素朴な実装のほうが速いということもあり得るかもしれません。</li>
    </ul>
    
    <hr class="separator" />
    <div class="copyright">&#169;Higasa Natsuiro(shade0710/shade0710math) 2013 All rights reserved.</div>
  </body>
</html>
